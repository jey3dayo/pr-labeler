# 要件定義書: コード複雑度分析

## はじめに

コード複雑度分析機能は、PR内の変更ファイルに対してESLint標準complexityルールを使用し、循環的複雑度（Cyclomatic Complexity）を自動計算する機能である。この機能により、開発者とレビュアーは、コードの複雑性を可視化し、保守性やテスト容易性の低下を早期に検知できる。PR Labeler機能で既に定義された複雑度ベースのラベル付け（complexity/medium、complexity/high）のバックエンドとして動作し、GitHub Actions Summaryでの詳細レポート出力も提供する。

## 要件

### 要件1: 循環的複雑度計算

**目的:** 開発者として、PR内の変更ファイルの循環的複雑度を自動的に計算し、コードの複雑性を定量的に評価したい。これにより、複雑なコードを早期に検知し、リファクタリングの必要性を判断できるようにする。

#### 受入基準

1. WHEN PRがオープン、同期、または再オープンされた場合 THEN コード複雑度分析システムは、変更されたすべてのファイルに対して循環的複雑度計算を実行するものとする
2. WHEN 変更ファイルを取得する場合 THEN システムは、GitHub APIのpull_requestイベントから追加（added）、変更（modified）、リネーム（renamed）されたファイルを対象とし、削除（deleted）されたファイルは除外するものとする
3. IF ファイルがリネーム（renamed）された場合 THEN システムは、リネーム後の新ファイルパスを複雑度計算の対象とするものとする
4. WHEN PRに含まれるファイル数が多い場合 THEN システムは、GitHub APIのページングを考慮し、最大3000ファイルまで取得するものとする
5. IF ファイルがTypeScriptまたはJavaScriptファイル（.ts、.tsx、.js、.jsx）の場合 THEN システムは、ESLint標準complexityルールを使用してファイル単位の循環的複雑度を計算するものとする
6. WHEN ESLintでTypeScript/TSXファイルを解析する場合 THEN システムは、@typescript-eslint/parserをパーサとして使用し、ecmaFeatures.jsxを有効化するものとする
7. WHEN TypeScriptプロジェクトのtsconfig.jsonが存在する場合 THEN システムは、プロジェクト参照を考慮してAST解析を実行するものとする
8. WHEN ライブラリのバージョンを管理する場合 THEN システムは、Node.js 20以上、TypeScript 5.x系、ESLint 9.x系をサポートする（ESLintは既存依存）ものとする
9. WHEN ファイルの循環的複雑度を計算する場合 THEN システムは、ファイル全体の複雑度と各関数/メソッドの個別複雑度を抽出するものとする
10. IF ファイルがTypeScript/JavaScript以外の拡張子を持つ場合 THEN システムは、そのファイルを複雑度計算の対象外として扱い、スキップするものとする
11. WHEN 複雑度計算が完了した場合 THEN システムは、ファイルごとの複雑度データ（ファイル名、合計複雑度、関数別複雑度、関数の行番号範囲）を構造化データとして保持するものとする

### 要件2: PR全体の複雑度集計

**目的:** テックリードとして、PR全体の複雑度メトリクスを把握し、レビュー優先度やリファクタリング対象を判断したい。これにより、チーム全体のコード品質を維持する。

#### 受入基準

1. WHEN ファイルレベルの複雑度を定義する場合 THEN システムは、ファイル内のすべての関数/メソッドの循環的複雑度の合計値をファイルの複雑度とするものとする
2. WHEN すべてのファイルの複雑度計算が完了した場合 THEN システムは、PR全体の最大複雑度（maxComplexity）を計算するものとする
3. WHEN PR全体の最大複雑度を計算する場合 THEN システムは、変更ファイル内のすべてのファイルレベル複雑度から最大値を抽出するものとする
4. WHEN PR全体の平均複雑度を計算する場合 THEN システムは、変更ファイル内のすべてのファイルレベル複雑度の単純平均を計算し、小数第1位で四捨五入するものとする
5. WHEN 高複雑度ファイルのリストを生成する場合 THEN システムは、設定された閾値（デフォルト: medium=15、high=30）を超えるファイルを抽出し、複雑度の降順でソートするものとする
6. IF 複雑度計算対象のファイルが0件の場合 THEN システムは、複雑度メトリクスをundefinedとして扱い、後続のラベル付与処理をスキップするものとする
7. WHEN 複雑度メトリクスのデータ構造を定義する場合 THEN システムは、以下のTypeScriptインタフェースに準拠するものとする：

```typescript
interface ComplexityMetrics {
  maxComplexity: number;           // PR全体の最大複雑度
  avgComplexity: number;           // PR全体の平均複雑度（小数第1位）
  analyzedFiles: number;           // 複雑度計算対象ファイル数
  files: FileComplexity[];         // ファイルごとの詳細データ
}

interface FileComplexity {
  path: string;                    // ファイルパス（リポジトリルートからの相対パス）
  complexity: number;              // ファイル全体の複雑度（関数複雑度の合計）
  functions: FunctionComplexity[]; // 関数ごとの複雑度データ
}

interface FunctionComplexity {
  name: string;                    // 関数/メソッド名
  complexity: number;              // 関数の循環的複雑度
  loc: {                           // 関数の行番号範囲
    start: number;                 // 開始行番号（1始まり）
    end: number;                   // 終了行番号（1始まり）
  };
}
```

### 要件3: 設定ベースの柔軟な制御

**目的:** プロジェクトマネージャーとして、プロジェクトの特性に応じて複雑度計算の動作をカスタマイズしたい。これにより、チームのワークフローに適した設定を適用できる。

#### 受入基準

1. WHEN 複雑度分析が有効化されている場合 THEN システムは、YAML設定ファイル（.github/pr-labeler.yml）のcomplexity.enabledフラグを読み取り、trueの場合のみ複雑度計算を実行するものとする
2. WHEN complexity.metricが指定されている場合 THEN システムは、指定されたメトリクス（デフォルト: cyclomatic）に基づいて計算戦略を選択するものとする
3. WHEN complexity.thresholdsが設定されている場合 THEN システムは、medium閾値とhigh閾値を読み取り、ラベル判定とレポート生成に適用するものとする
4. IF complexity.extensionsが指定されている場合 THEN システムは、指定された拡張子のみを複雑度計算対象として処理するものとする
5. WHEN complexity.excludeパターンが設定されている場合 THEN システムは、minimatch形式のglobパターン（例: `**/dist/**`, `**/vendor/**`, `**/*.spec.ts`）に一致するファイルを複雑度計算から除外するものとする
6. WHEN デフォルトの除外パターンを適用する場合 THEN システムは、ビルド成果物（`**/dist/**`, `**/build/**`）、依存関係（`**/node_modules/**`, `**/vendor/**`）、テストファイル（`**/*.test.ts`, `**/*.spec.ts`）、生成コード（`**/*.generated.ts`, `**/__generated__/**`）を自動的に除外するものとする
7. WHEN 拡張子フィルタと除外パターンが両方設定されている場合 THEN システムは、まず拡張子でフィルタリングし、その後に除外パターンを適用するものとする（除外パターンの優先度が高い）
8. WHEN 設定ファイルが存在しない場合 THEN システムは、デフォルト設定（enabled: true、metric: cyclomatic、medium: 15、high: 30、extensions: [.ts, .tsx, .js, .jsx]、デフォルト除外パターン有効）を適用するものとする

### 要件4: PR Labeler統合

**目的:** 開発者として、複雑度分析の結果を自動的にPRラベルに反映させ、レビュアーに複雑性の情報を視覚的に提供したい。これにより、レビュープロセスの効率化と品質向上を実現する。

#### 受入基準

1. WHEN 複雑度計算が完了した場合 THEN システムは、計算されたmaxComplexityをPRMetrics.complexity.maxComplexityとしてラベル判定エンジンに渡すものとする
2. WHEN 最大複雑度が設定されたhigh閾値以上の場合 THEN ラベル判定エンジンは、complexity/highラベルを付与するものとする
3. WHEN 最大複雑度が設定されたmedium閾値以上かつhigh閾値未満の場合 THEN ラベル判定エンジンは、complexity/mediumラベルを付与するものとする
4. WHEN 最大複雑度がmedium閾値未満の場合 THEN ラベル判定エンジンは、複雑度ラベルを付与しないものとする
5. WHEN 既存のcomplexity/*ラベルが複数存在する場合 THEN システムは、すべての既存complexity/*ラベルを削除してから、新しいラベルを追加するものとする（置換ポリシー）
6. WHEN ラベル削除または追加の処理順序を決定する場合 THEN システムは、まず既存ラベルをすべて削除し、その後に新しいラベルを追加するものとする
7. WHEN GitHub APIでラベル操作がエラーになった場合 THEN システムは、指数バックオフ戦略で最大3回までリトライし、すべて失敗した場合はエラーログを記録するがCI全体は失敗させないものとする
8. WHEN GitHub APIトークンの権限を確認する場合 THEN システムは、pull-requests: writeスコープを必要とし、権限がない場合は警告をログ出力するものとする

### 要件5: GitHub Actions Summary出力

**目的:** 品質保証担当者として、CI/CDワークフローのサマリーページで複雑度メトリクスの詳細レポートを確認したい。これにより、PR承認前に複雑度の詳細を把握できる。

#### 受入基準

1. WHEN 複雑度計算が完了した場合 THEN システムは、GitHub Actions Summaryに複雑度セクションを追加するものとする
2. WHEN 複雑度サマリーを生成する場合 THEN システムは、以下の情報をMarkdownテーブルとして表示するものとする：
   - PR全体の最大複雑度（整数、3桁カンマ区切り）
   - PR全体の平均複雑度（小数第1位まで）
   - 複雑度計算対象ファイル数（整数、3桁カンマ区切り）
3. WHEN 高複雑度ファイルのリストを表示する場合 THEN システムは、medium閾値を超えるファイルを最大20件まで表示し、複雑度の降順でソートするものとする
4. WHEN 高複雑度ファイルのリストアイテムを生成する場合 THEN システムは、ファイル名をGitHubリポジトリURLへのリンクとし、複雑度値と閾値超過レベル（medium/high）を表示するものとする
5. WHEN 関数別複雑度の詳細表示を有効にする場合 THEN システムは、`<details><summary>...</summary>...</details>`形式で折りたたみ可能な表示を実装するものとする
6. WHEN 関数別複雑度の詳細を表示する場合 THEN システムは、各高複雑度ファイルごとに複雑度上位10関数を表示し、関数名と行番号をGitHubリポジトリURLリンクとして提供するものとする
7. WHEN 数値フォーマットを適用する場合 THEN システムは、整数には3桁カンマ区切り（例: 1,234）、小数には第1位まで表示（例: 12.3）するものとする
8. IF 複雑度計算対象ファイルが0件の場合 THEN システムは、"No files analyzed for complexity (all files excluded or no supported files found)"というメッセージを表示するものとする
9. IF 高複雑度ファイルが存在しない場合 THEN システムは、"No complexity issues found (all files below medium threshold)"というメッセージを表示するものとする
10. IF 複雑度計算がスキップされた場合（enabled: false） THEN システムは、複雑度セクションをサマリーに含めないものとする

### 要件6: エラーハンドリングとパフォーマンス

**目的:** CI/CD管理者として、複雑度計算が失敗した場合でも全体のワークフローが中断されないようにし、パフォーマンスを維持したい。これにより、安定したCI/CDパイプラインを提供する。

#### 受入基準

1. WHEN ESLintがファイルの解析に失敗した場合 THEN システムは、そのファイルをスキップし、エラーログを記録し、他のファイルの計算を継続するものとする
2. WHEN ファイルのASTパースが構文エラーで失敗した場合 THEN システムは、そのファイルの複雑度を0として記録し、警告をログに出力するものとする
3. WHEN 複雑度計算の全体タイムアウトを設定する場合 THEN システムは、デフォルト60秒をタイムアウトとし、超過した場合は計算を中止して部分的な結果を返すものとする
4. WHEN 個別ファイルのタイムアウトを設定する場合 THEN システムは、単一ファイルあたり最大5秒をタイムアウトとし、超過したファイルはスキップするものとする
5. WHEN 大規模PR（100ファイル以上）で複雑度計算を実行する場合 THEN システムは、並列処理によって5秒以内に完了することを目標値とし、SLAではなくベストエフォートとして扱うものとする
6. WHEN 実行環境を考慮する場合 THEN システムは、GitHubホストランナー（Ubuntu最新版、2コアCPU）を基準とし、自己ホストランナーでは別途チューニングが必要であることを明記するものとする
7. WHEN 並列処理の並列度を決定する場合 THEN システムは、デフォルトでCPUコア数の2倍を並列度とし、最大8並列までとするものとする
8. WHEN パフォーマンス計測を実装する場合 THEN システムは、複雑度計算の開始時刻と終了時刻をログ出力し、10秒を超えた場合はGitHub Actions annotationsで警告を表示するものとする
9. IF 複雑度計算中に予期しないエラーが発生した場合 THEN システムは、Result<T, E>パターンを使用してエラーを返し、CI全体を失敗させないものとする

### 要件7: 後方互換性と段階的移行

**目的:** プロジェクトオーナーとして、既存のPR Metrics Actionユーザーが複雑度分析機能を段階的に導入できるようにしたい。これにより、既存ワークフローへの影響を最小化する。

#### 受入基準

1. WHEN action.ymlに新しいenable_complexity_analysis入力が追加された場合 THEN デフォルト値はfalseとし、既存ユーザーの動作を変更しないものとする
2. WHEN 複雑度分析が無効な場合 THEN システムは、PRMetrics.complexityをundefinedとして扱い、複雑度関連のラベル付与とサマリー出力をスキップするものとする
3. WHEN PR Labelerの設定ファイルが存在しない場合 THEN システムは、action.ymlのenable_complexity_analysis入力のみを参照し、デフォルト設定で複雑度計算を実行するものとする
4. IF PR Labelerの設定ファイルが存在する場合 THEN システムは、設定ファイルのcomplexity.enabledフラグを優先し、action.yml入力を無視するものとする
5. WHEN v1.2.0から既存ユーザーがアップグレードした場合 THEN システムは、既存のワークフロー定義を変更せずに動作し、複雑度機能は明示的に有効化した場合のみ動作するものとする

### 要件8: テスト方針と品質保証

**目的:** 品質保証担当者として、複雑度計算の正確性、信頼性、パフォーマンスを検証したい。これにより、本番環境での安定動作を保証する。

#### 受入基準

1. WHEN 複雑度計算の正確性を検証する場合 THEN システムは、代表的なTypeScript、TSX、JavaScript、JSXサンプルファイルを用意し、期待される複雑度値との一致を確認するものとする
2. WHEN 閾値境界のテストを実施する場合 THEN システムは、medium閾値-1、medium閾値、high閾値-1、high閾値の各複雑度値を持つテストファイルを作成し、正しくラベル判定されることを確認するものとする
3. WHEN 解析失敗時の挙動をテストする場合 THEN システムは、構文エラーを含むファイルで複雑度が0として記録されること、AST解析失敗時にファイルがスキップされることを確認するものとする
4. WHEN パフォーマンステストを実施する場合 THEN システムは、100ファイルの模擬PRを作成し、実行時間を測定して目標値（5秒以内）との差異を記録するものとする
5. WHEN 複雑度結果の一貫性を保証する場合 THEN システムは、Vitestのスナップショットテストを使用し、ComplexityMetrics JSONの構造と値が予期した形式であることを確認するものとする
6. WHEN テストカバレッジを測定する場合 THEN システムは、複雑度計算関連モジュールで90%以上のカバレッジを達成するものとする

## 備考

### 将来の拡張可能性

以下の機能は、現在のv1.2.0スコープには含まれないが、将来のバージョンで検討する：

1. **差分ベースの複雑度計算**
   - 現在: PR内の変更ファイル全体の複雑度を計算
   - 将来: 差分行に含まれる関数のみを対象とする機能を追加
   - ユースケース: 大規模ファイルの一部変更時に、変更箇所の複雑度のみを評価

2. **増分複雑度の可視化**
   - 現在: PRの複雑度のみを計算
   - 将来: PRマージ前後の複雑度比較（before/after）を提供
   - ユースケース: リファクタリングによる複雑度改善を定量的に可視化

3. **他の複雑度メトリクスのサポート**
   - 現在: 循環的複雑度（Cyclomatic Complexity）のみ
   - 将来: Halstead指標、認知的複雑度（Cognitive Complexity）の追加
   - ユースケース: より包括的なコード品質評価
