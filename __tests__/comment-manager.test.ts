import * as core from '@actions/core';
import * as github from '@actions/github';
import { afterEach, beforeEach, describe, expect, it, vi } from 'vitest';

// Setup mocks
vi.mock('@actions/github');
vi.mock('@actions/core');

// Import after mocking
import {
  COMMENT_SIGNATURE,
  CommentConfig,
  deleteComment,
  findExistingComment,
  generateCommentBody,
  manageComment,
  postComment,
  updateComment,
} from '../src/comment-manager';
import type { AnalysisResult } from '../src/file-metrics';
import { changeLanguage, initializeI18n, resetI18n } from '../src/i18n';

describe('CommentManager', () => {
  let mockOctokit: any;
  let mockListComments: ReturnType<typeof vi.fn>;
  let mockCreateComment: ReturnType<typeof vi.fn>;
  let mockUpdateComment: ReturnType<typeof vi.fn>;
  let mockDeleteComment: ReturnType<typeof vi.fn>;
  let mockPaginateIterator: ReturnType<typeof vi.fn>;

  // Helper to create async iterator for pagination
  const createPaginateIterator = (pages: any[][]) => {
    return (async function* () {
      for (const data of pages) {
        yield { data };
      }
    })();
  };

  beforeEach(() => {
    vi.clearAllMocks();

    // Mock Date for consistent timestamp in snapshots
    vi.setSystemTime(new Date('2025-10-18T15:30:00Z'));

    // Initialize i18n with English for consistent test results
    resetI18n();
    initializeI18n('en');
    changeLanguage('en'); // 明示的に英語に変更

    // Setup GitHub mock
    mockListComments = vi.fn();
    mockCreateComment = vi.fn();
    mockUpdateComment = vi.fn();
    mockDeleteComment = vi.fn();
    mockPaginateIterator = vi.fn();

    mockOctokit = {
      rest: {
        issues: {
          listComments: mockListComments,
          createComment: mockCreateComment,
          updateComment: mockUpdateComment,
          deleteComment: mockDeleteComment,
        },
      },
      paginate: {
        iterator: mockPaginateIterator,
      },
    };

    vi.mocked(github.getOctokit).mockReturnValue(mockOctokit);
    vi.mocked(core.info).mockImplementation(() => {});
    vi.mocked(core.warning).mockImplementation(() => {});
  });

  afterEach(() => {
    vi.resetAllMocks();
    vi.useRealTimers();
  });

  describe('generateCommentBody', () => {
    describe('i18n support', () => {
      it('should generate comment with English header and footer', () => {
        changeLanguage('en');
        const analysisResult: AnalysisResult = {
          metrics: {
            totalFiles: 5,
            totalAdditions: 100,
            filesAnalyzed: [],
            filesExcluded: ['package-lock.json'],
            filesSkippedBinary: ['image.png'],
            filesWithErrors: [],
          },
          violations: {
            largeFiles: [],
            exceedsFileLines: [],
            exceedsAdditions: false,
            exceedsFileCount: false,
          },
        };

        const body = generateCommentBody(analysisResult);
        expect(body).toContain('✅ PR Size Check Passed');
        expect(body).toContain('Generated by [PR Labeler](https://github.com/marketplace/actions/pr-labeler)');
      });

      it('should generate comment with Japanese header and footer', () => {
        changeLanguage('ja');
        const analysisResult: AnalysisResult = {
          metrics: {
            totalFiles: 5,
            totalAdditions: 100,
            filesAnalyzed: [],
            filesExcluded: ['package-lock.json'],
            filesSkippedBinary: ['image.png'],
            filesWithErrors: [],
          },
          violations: {
            largeFiles: [],
            exceedsFileLines: [],
            exceedsAdditions: false,
            exceedsFileCount: false,
          },
        };

        const body = generateCommentBody(analysisResult);
        expect(body).toContain('✅ PRサイズチェック合格');
        expect(body).toContain('[PR Labeler](https://github.com/marketplace/actions/pr-labeler)により生成');

        // Reset to English for other tests
        changeLanguage('en');
      });

      it('should generate comment with English error section', () => {
        changeLanguage('en');
        const analysisResult: AnalysisResult = {
          metrics: {
            totalFiles: 3,
            totalAdditions: 50,
            filesAnalyzed: [],
            filesExcluded: [],
            filesSkippedBinary: [],
            filesWithErrors: ['src/error1.ts', 'src/error2.ts'],
          },
          violations: {
            largeFiles: [],
            exceedsFileLines: [],
            exceedsAdditions: false,
            exceedsFileCount: false,
          },
        };

        const body = generateCommentBody(analysisResult);
        expect(body).toContain('### ⚠️ Analysis Errors');
        expect(body).toContain('Some files could not be analyzed:');
      });

      it('should generate comment with Japanese error section', () => {
        changeLanguage('ja');
        const analysisResult: AnalysisResult = {
          metrics: {
            totalFiles: 3,
            totalAdditions: 50,
            filesAnalyzed: [],
            filesExcluded: [],
            filesSkippedBinary: [],
            filesWithErrors: ['src/error1.ts', 'src/error2.ts'],
          },
          violations: {
            largeFiles: [],
            exceedsFileLines: [],
            exceedsAdditions: false,
            exceedsFileCount: false,
          },
        };

        const body = generateCommentBody(analysisResult);
        expect(body).toContain('### ⚠️ 分析エラー');
        expect(body).toContain('一部のファイルを分析できませんでした:');

        // Reset to English for other tests
        changeLanguage('en');
      });

      it('should generate violation header in Japanese', () => {
        changeLanguage('ja');
        const analysisResult: AnalysisResult = {
          metrics: {
            totalFiles: 10,
            totalAdditions: 1500,
            filesAnalyzed: [],
            filesExcluded: [],
            filesSkippedBinary: [],
            filesWithErrors: [],
          },
          violations: {
            largeFiles: [],
            exceedsFileLines: [],
            exceedsAdditions: true,
            exceedsFileCount: false,
          },
        };

        const body = generateCommentBody(analysisResult);
        expect(body).toContain('📊 PRサイズチェック - 大規模なPRを検出');

        // Reset to English for other tests
        changeLanguage('en');
      });
    });

    describe('snapshot tests (for refactoring safety)', () => {
      it('should match snapshot: no violations', () => {
        const analysisResult: AnalysisResult = {
          metrics: {
            totalFiles: 5,
            totalAdditions: 100,
            filesAnalyzed: [],
            filesExcluded: ['package-lock.json'],
            filesSkippedBinary: ['image.png'],
            filesWithErrors: [],
          },
          violations: {
            largeFiles: [],
            exceedsFileLines: [],
            exceedsAdditions: false,
            exceedsFileCount: false,
          },
        };

        const body = generateCommentBody(analysisResult);
        expect(body).toMatchSnapshot();
      });

      it('should match snapshot: with violations', () => {
        const analysisResult: AnalysisResult = {
          metrics: {
            totalFiles: 10,
            totalAdditions: 1500,
            filesAnalyzed: [
              {
                path: 'src/large.ts',
                size: 2000000,
                lines: 2000,
                additions: 1000,
                deletions: 0,
              },
              {
                path: 'src/normal.ts',
                size: 5000,
                lines: 100,
                additions: 50,
                deletions: 10,
              },
            ],
            filesExcluded: [],
            filesSkippedBinary: [],
            filesWithErrors: [],
          },
          violations: {
            largeFiles: [
              {
                file: 'src/large.ts',
                actualValue: 2000000,
                limit: 1000000,
                violationType: 'size',
                severity: 'critical',
              },
            ],
            exceedsFileLines: [
              {
                file: 'src/large.ts',
                actualValue: 2000,
                limit: 1000,
                violationType: 'lines',
                severity: 'warning',
              },
            ],
            exceedsAdditions: true,
            exceedsFileCount: false,
          },
        };

        const body = generateCommentBody(analysisResult);
        expect(body).toMatchSnapshot();
      });

      it('should match snapshot: large PR with many files', () => {
        const analysisResult: AnalysisResult = {
          metrics: {
            totalFiles: 5,
            totalAdditions: 200,
            filesAnalyzed: [
              {
                path: 'src/file1.ts',
                size: 50000,
                lines: 500,
                additions: 100,
                deletions: 20,
              },
              {
                path: 'src/file2.ts',
                size: 30000,
                lines: 300,
                additions: 50,
                deletions: 10,
              },
              {
                path: 'src/file3.ts',
                size: 20000,
                lines: 200,
                additions: 30,
                deletions: 5,
              },
              {
                path: 'src/file4.ts',
                size: 10000,
                lines: 100,
                additions: 15,
                deletions: 2,
              },
              {
                path: 'src/file5.ts',
                size: 5000,
                lines: 50,
                additions: 5,
                deletions: 1,
              },
            ],
            filesExcluded: [],
            filesSkippedBinary: [],
            filesWithErrors: [],
          },
          violations: {
            largeFiles: [],
            exceedsFileLines: [],
            exceedsAdditions: false,
            exceedsFileCount: false,
          },
        };

        const body = generateCommentBody(analysisResult);
        expect(body).toMatchSnapshot();
      });

      it('should match snapshot: with errors', () => {
        const analysisResult: AnalysisResult = {
          metrics: {
            totalFiles: 3,
            totalAdditions: 50,
            filesAnalyzed: [],
            filesExcluded: [],
            filesSkippedBinary: [],
            filesWithErrors: ['src/error1.ts', 'src/error2.ts'],
          },
          violations: {
            largeFiles: [],
            exceedsFileLines: [],
            exceedsAdditions: false,
            exceedsFileCount: false,
          },
        };

        const body = generateCommentBody(analysisResult);
        expect(body).toMatchSnapshot();
      });
    });

    it('should generate success message when no violations', () => {
      const analysisResult: AnalysisResult = {
        metrics: {
          totalFiles: 5,
          totalAdditions: 100,
          filesAnalyzed: [],
          filesExcluded: ['package-lock.json'],
          filesSkippedBinary: ['image.png'],
          filesWithErrors: [],
        },
        violations: {
          largeFiles: [],
          exceedsFileLines: [],
          exceedsAdditions: false,
          exceedsFileCount: false,
        },
      };

      const body = generateCommentBody(analysisResult);

      expect(body).toContain('✅ PR Size Check Passed');
      expect(body).toContain('All files are within size limits');
      expect(body).toContain('Total Additions: **100**');
      expect(body).toContain('Total Files Changed: **0**');
      expect(body).toContain('Excluded Files: **1**');
      expect(body).toContain('Binary files skipped: **1**');
      expect(body).toContain(COMMENT_SIGNATURE);
    });

    it('should generate warning message with violations', () => {
      const analysisResult: AnalysisResult = {
        metrics: {
          totalFiles: 10,
          totalAdditions: 1500,
          filesAnalyzed: [
            {
              path: 'src/large.ts',
              size: 2000000,
              lines: 2000,
              additions: 1000,
              deletions: 0,
            },
            {
              path: 'src/normal.ts',
              size: 5000,
              lines: 100,
              additions: 50,
              deletions: 10,
            },
          ],
          filesExcluded: [],
          filesSkippedBinary: [],
          filesWithErrors: [],
        },
        violations: {
          largeFiles: [
            {
              file: 'src/large.ts',
              actualValue: 2000000,
              limit: 1000000,
              violationType: 'size',
              severity: 'critical',
            },
          ],
          exceedsFileLines: [
            {
              file: 'src/large.ts',
              actualValue: 2000,
              limit: 1000,
              violationType: 'lines',
              severity: 'warning',
            },
          ],
          exceedsAdditions: true,
          exceedsFileCount: false,
        },
      };

      const body = generateCommentBody(analysisResult);

      expect(body).toContain('📊 PR Size Check - Large PR Detected');
      expect(body).toContain('### 📊 Size Summary');
      expect(body).toContain('Total additions exceed limit');
      // Detailed violation tables removed - now shown in unified formatFileAnalysis
      expect(body).not.toContain('### 🚫 Large Files Detected');
      expect(body).not.toContain('### ⚠️ Files Exceed Line Limit');
      // Check for unified file analysis table instead
      expect(body).toContain('### 📊 File Analysis');
      expect(body).toContain('| File Name | Size | Lines | Changes | Status |');
      expect(body).toContain(COMMENT_SIGNATURE);
    });

    it('should include top large files table', () => {
      const analysisResult: AnalysisResult = {
        metrics: {
          totalFiles: 5,
          totalAdditions: 200,
          filesAnalyzed: [
            {
              path: 'src/file1.ts',
              size: 50000,
              lines: 500,
              additions: 100,
              deletions: 20,
            },
            {
              path: 'src/file2.ts',
              size: 30000,
              lines: 300,
              additions: 50,
              deletions: 10,
            },
            {
              path: 'src/file3.ts',
              size: 20000,
              lines: 200,
              additions: 30,
              deletions: 5,
            },
            {
              path: 'src/file4.ts',
              size: 10000,
              lines: 100,
              additions: 15,
              deletions: 2,
            },
            {
              path: 'src/file5.ts',
              size: 5000,
              lines: 50,
              additions: 5,
              deletions: 1,
            },
          ],
          filesExcluded: [],
          filesSkippedBinary: [],
          filesWithErrors: [],
        },
        violations: {
          largeFiles: [],
          exceedsFileLines: [],
          exceedsAdditions: false,
          exceedsFileCount: false,
        },
      };

      const body = generateCommentBody(analysisResult);

      // Updated: Now uses formatFileAnalysis which includes Status column
      expect(body).toContain('### 📊 File Analysis');
      expect(body).toContain('| File Name | Size | Lines | Changes | Status |');
      expect(body).toContain('src/file1.ts');
      expect(body).toContain('48.8 KB');
      expect(body).toContain('500');
      expect(body).toContain('+100/-20');
      expect(body).toContain('✅ OK');
    });

    it('should format bytes correctly', () => {
      const analysisResult: AnalysisResult = {
        metrics: {
          totalFiles: 1,
          totalAdditions: 10,
          filesAnalyzed: [
            {
              path: 'small.ts',
              size: 512,
              lines: 10,
              additions: 10,
              deletions: 0,
            },
          ],
          filesExcluded: [],
          filesSkippedBinary: [],
          filesWithErrors: [],
        },
        violations: {
          largeFiles: [],
          exceedsFileLines: [],
          exceedsAdditions: false,
          exceedsFileCount: false,
        },
      };

      const body = generateCommentBody(analysisResult);
      expect(body).toContain('512 B'); // Updated to match actual format (no decimal places for whole numbers)
    });

    it('should handle empty analysis result', () => {
      const analysisResult: AnalysisResult = {
        metrics: {
          totalFiles: 0,
          totalAdditions: 0,
          filesAnalyzed: [],
          filesExcluded: [],
          filesSkippedBinary: [],
          filesWithErrors: [],
        },
        violations: {
          largeFiles: [],
          exceedsFileLines: [],
          exceedsAdditions: false,
          exceedsFileCount: false,
        },
      };

      const body = generateCommentBody(analysisResult);

      expect(body).toContain('✅ PR Size Check Passed');
      expect(body).toContain('No files to display');
    });

    it('should show files with errors if present', () => {
      const analysisResult: AnalysisResult = {
        metrics: {
          totalFiles: 3,
          totalAdditions: 50,
          filesAnalyzed: [],
          filesExcluded: [],
          filesSkippedBinary: [],
          filesWithErrors: ['src/error1.ts', 'src/error2.ts'],
        },
        violations: {
          largeFiles: [],
          exceedsFileLines: [],
          exceedsAdditions: false,
          exceedsFileCount: false,
        },
      };

      const body = generateCommentBody(analysisResult);

      expect(body).toContain('Files with errors: **2**');
      expect(body).toContain('### ⚠️ Analysis Errors'); // Check for the section heading
      expect(body).toContain('Some files could not be analyzed:'); // Updated to match actual text (no emoji in this specific line)
    });
  });

  describe('findExistingComment', () => {
    it('should find comment with signature', async () => {
      mockPaginateIterator.mockReturnValue(
        createPaginateIterator([
          [
            { id: 1, body: 'Regular comment' },
            { id: 2, body: `Some content\n${COMMENT_SIGNATURE}` },
            { id: 3, body: 'Another comment' },
          ],
        ]),
      );

      const result = await findExistingComment('token', {
        owner: 'owner',
        repo: 'repo',
        pullNumber: 123,
      });

      expect(result.isOk()).toBe(true);
      if (result.isOk()) {
        expect(result.value).toBe(2);
      }
    });

    it('should return null when no matching comment', async () => {
      mockPaginateIterator.mockReturnValue(
        createPaginateIterator([
          [
            { id: 1, body: 'Regular comment' },
            { id: 2, body: 'Another comment' },
          ],
        ]),
      );

      const result = await findExistingComment('token', {
        owner: 'owner',
        repo: 'repo',
        pullNumber: 123,
      });

      expect(result.isOk()).toBe(true);
      if (result.isOk()) {
        expect(result.value).toBeNull();
      }
    });

    it('should handle pagination', async () => {
      mockPaginateIterator.mockReturnValue(
        createPaginateIterator([
          Array.from({ length: 100 }, (_, i) => ({
            id: i + 1,
            body: `Comment ${i + 1}`,
          })),
          [
            { id: 101, body: `Match\n${COMMENT_SIGNATURE}` },
            { id: 102, body: 'Last comment' },
          ],
        ]),
      );

      const result = await findExistingComment('token', {
        owner: 'owner',
        repo: 'repo',
        pullNumber: 123,
      });

      expect(result.isOk()).toBe(true);
      if (result.isOk()) {
        expect(result.value).toBe(101);
      }
    });

    it('should return error on API failure', async () => {
      mockPaginateIterator.mockImplementation(() => {
        throw new Error('API error');
      });

      const result = await findExistingComment('token', {
        owner: 'owner',
        repo: 'repo',
        pullNumber: 123,
      });

      expect(result.isErr()).toBe(true);
      if (result.isErr()) {
        expect(result.error.type).toBe('GitHubAPIError');
      }
    });
  });

  describe('postComment', () => {
    it('should create new comment', async () => {
      mockCreateComment.mockResolvedValue({
        data: { id: 123, body: 'Test comment' },
      });

      const result = await postComment('Test comment', 'token', {
        owner: 'owner',
        repo: 'repo',
        pullNumber: 123,
      });

      expect(result.isOk()).toBe(true);
      expect(mockCreateComment).toHaveBeenCalledWith({
        owner: 'owner',
        repo: 'repo',
        issue_number: 123,
        body: 'Test comment',
      });
    });

    it('should return error on failure', async () => {
      mockCreateComment.mockRejectedValue(new Error('Permission denied'));

      const result = await postComment('Test', 'token', {
        owner: 'owner',
        repo: 'repo',
        pullNumber: 123,
      });

      expect(result.isErr()).toBe(true);
      if (result.isErr()) {
        expect(result.error.type).toBe('GitHubAPIError');
      }
    });
  });

  describe('updateComment', () => {
    it('should update existing comment', async () => {
      mockUpdateComment.mockResolvedValue({
        data: { id: 123, body: 'Updated' },
      });

      const result = await updateComment(123, 'Updated', 'token', {
        owner: 'owner',
        repo: 'repo',
        pullNumber: 123,
      });

      expect(result.isOk()).toBe(true);
      expect(mockUpdateComment).toHaveBeenCalledWith({
        owner: 'owner',
        repo: 'repo',
        comment_id: 123,
        body: 'Updated',
      });
    });
  });

  describe('deleteComment', () => {
    it('should delete comment', async () => {
      mockDeleteComment.mockResolvedValue({});

      const result = await deleteComment(123, 'token', {
        owner: 'owner',
        repo: 'repo',
        pullNumber: 123,
      });

      expect(result.isOk()).toBe(true);
      expect(mockDeleteComment).toHaveBeenCalledWith({
        owner: 'owner',
        repo: 'repo',
        comment_id: 123,
      });
    });
  });

  describe('manageComment', () => {
    it('should create comment when mode is always', async () => {
      const config: CommentConfig = {
        commentMode: 'always',
      };

      const analysisResult: AnalysisResult = {
        metrics: {
          totalFiles: 1,
          totalAdditions: 10,
          filesAnalyzed: [],
          filesExcluded: [],
          filesSkippedBinary: [],
          filesWithErrors: [],
        },
        violations: {
          largeFiles: [],
          exceedsFileLines: [],
          exceedsAdditions: false,
          exceedsFileCount: false,
        },
      };

      mockPaginateIterator.mockReturnValue(createPaginateIterator([[]]));
      mockCreateComment.mockResolvedValue({ data: { id: 123 } });

      const result = await manageComment(analysisResult, config, 'token', {
        owner: 'owner',
        repo: 'repo',
        pullNumber: 123,
      });

      expect(result.isOk()).toBe(true);
      if (result.isOk()) {
        expect(result.value.action).toBe('created');
        expect(result.value.commentId).toBe(123);
      }
    });

    it('should update existing comment when mode is always', async () => {
      const config: CommentConfig = {
        commentMode: 'always',
      };

      const analysisResult: AnalysisResult = {
        metrics: {
          totalFiles: 1,
          totalAdditions: 10,
          filesAnalyzed: [],
          filesExcluded: [],
          filesSkippedBinary: [],
          filesWithErrors: [],
        },
        violations: {
          largeFiles: [],
          exceedsFileLines: [],
          exceedsAdditions: false,
          exceedsFileCount: false,
        },
      };

      mockPaginateIterator.mockReturnValue(createPaginateIterator([[{ id: 456, body: `Old\n${COMMENT_SIGNATURE}` }]]));
      mockUpdateComment.mockResolvedValue({ data: { id: 456 } });

      const result = await manageComment(analysisResult, config, 'token', {
        owner: 'owner',
        repo: 'repo',
        pullNumber: 123,
      });

      expect(result.isOk()).toBe(true);
      if (result.isOk()) {
        expect(result.value.action).toBe('updated');
        expect(result.value.commentId).toBe(456);
      }
    });

    it('should create comment only on violations when mode is auto', async () => {
      const config: CommentConfig = {
        commentMode: 'auto',
      };

      // With violations
      const withViolations: AnalysisResult = {
        metrics: {
          totalFiles: 1,
          totalAdditions: 1000,
          filesAnalyzed: [],
          filesExcluded: [],
          filesSkippedBinary: [],
          filesWithErrors: [],
        },
        violations: {
          largeFiles: [],
          exceedsFileLines: [],
          exceedsAdditions: true,
          exceedsFileCount: false,
        },
      };

      mockPaginateIterator.mockReturnValueOnce(createPaginateIterator([[]]));
      mockCreateComment.mockResolvedValue({ data: { id: 789 } });

      let result = await manageComment(withViolations, config, 'token', {
        owner: 'owner',
        repo: 'repo',
        pullNumber: 123,
      });

      expect(result.isOk()).toBe(true);
      if (result.isOk()) {
        expect(result.value.action).toBe('created');
      }

      // Without violations - should delete existing comment
      const noViolations: AnalysisResult = {
        ...withViolations,
        violations: {
          largeFiles: [],
          exceedsFileLines: [],
          exceedsAdditions: false,
          exceedsFileCount: false,
        },
      };

      mockPaginateIterator.mockReturnValueOnce(
        createPaginateIterator([[{ id: 789, body: `Old\n${COMMENT_SIGNATURE}` }]]),
      );
      mockDeleteComment.mockResolvedValue({});

      result = await manageComment(noViolations, config, 'token', {
        owner: 'owner',
        repo: 'repo',
        pullNumber: 123,
      });

      expect(result.isOk()).toBe(true);
      if (result.isOk()) {
        expect(result.value.action).toBe('deleted');
        expect(result.value.commentId).toBe(789);
      }
    });

    it('should never create comment when mode is never', async () => {
      const config: CommentConfig = {
        commentMode: 'never',
      };

      const analysisResult: AnalysisResult = {
        metrics: {
          totalFiles: 1,
          totalAdditions: 1000,
          filesAnalyzed: [],
          filesExcluded: [],
          filesSkippedBinary: [],
          filesWithErrors: [],
        },
        violations: {
          largeFiles: [],
          exceedsFileLines: [],
          exceedsAdditions: true,
          exceedsFileCount: false,
        },
      };

      // Should delete existing comment if present
      mockPaginateIterator.mockReturnValue(createPaginateIterator([[{ id: 999, body: `Old\n${COMMENT_SIGNATURE}` }]]));
      mockDeleteComment.mockResolvedValue({});

      const result = await manageComment(analysisResult, config, 'token', {
        owner: 'owner',
        repo: 'repo',
        pullNumber: 123,
      });

      expect(result.isOk()).toBe(true);
      if (result.isOk()) {
        expect(result.value.action).toBe('deleted');
      }
      expect(mockCreateComment).not.toHaveBeenCalled();
    });
  });
});
